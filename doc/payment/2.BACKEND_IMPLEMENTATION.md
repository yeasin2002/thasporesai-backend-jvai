# Backend Implementation Guide

**Version**: 2.0.0  
**Last Updated**: January 29, 2026  
**Status**: ‚úÖ Production Ready with Stripe Integration Complete

> **üìù Implementation Note**: This guide uses simplified pseudocode examples to illustrate concepts. The actual implementation uses helper functions and the centralized `db` object for database access. See `DOCUMENTATION_UPDATE_SUMMARY.md` for details on actual implementation patterns.

---

## Table of Contents

1. [Overview](#overview)
2. [New Payment Architecture](#new-payment-architecture)
3. [Database Models](#database-models)
4. [Payment Configuration](#payment-configuration)
5. [Service Layer Implementation](#service-layer-implementation)
6. [Stripe Integration](#stripe-integration)
7. [Testing Stripe Endpoints](#testing-stripe-endpoints)
8. [Validation Checklist](#validation-checklist)
9. [Error Handling](#error-handling)
10. [Best Practices](#best-practices)

---

## Overview

This guide provides detailed implementation instructions for the JobSphere payment system. It's designed for backend developers and team members who will work on payment-related features.

### What Changed in v2.0

The new payment system simplifies money transfers by using Stripe as the "bank" and tracking transactions via database wallet balances:

**Old System**:
- Escrow balance + available balance in wallet
- Real-time Stripe balance synchronization

**New System**:
- Single balance in wallet (tracked in database)
- Stripe holds real money, wallet tracks ownership
- Minimal real money transfers (only deposits and approved withdrawals/payouts)
- Admin approval required for all outgoing money

### Key Principles

1. **Stripe = Bank**: All real money stays in Stripe
2. **Wallet = Ledger**: Database tracks who owns what money
3. **Minimal Transfers**: Only deposit and admin-approved withdrawals
4. **Wallet Updates**: All transactions update database balances immediately
5. **Admin Controls**: All real money outflows require admin approval

---

## New Payment Architecture

### Money Flow Diagram

```
CUSTOMER DEPOSITS
  ‚Üì
Backend creates Stripe Checkout Session
  ‚Üì
Customer opens URL in browser (not in-app)
  ‚Üì
Customer completes payment on Stripe
  ‚Üì
Stripe sends webhook ‚Üí Backend
  ‚Üì
Backend updates customer wallet in DB (+$200)
  ‚Üì
Real money: Stripe | Virtual tracking: DB Wallet
```

```
OFFER ACCEPTED
  ‚Üì
Customer wallet: -$105 (DB only)
Admin wallet: +$105 (DB only)
  ‚Üì
NO REAL MONEY TRANSFER
  ‚Üì
Real money: Still in Stripe | Virtual: Admin "has" $105
```

```
JOB COMPLETED
  ‚Üì
Customer marks complete ‚Üí Admin reviews
  ‚Üì
Admin approves completion
  ‚Üì
DB updates:
  Admin wallet: -$80
  Contractor wallet: +$80
  Admin keeps: $25 commission
  ‚Üì
Admin initiates Stripe Connect transfer
  ‚Üì
Stripe transfers $80 to contractor's bank
  ‚Üì
Real money: Moves from Stripe to contractor bank
```

### Transaction Types

| Type | When | DB Changes | Real Money | Who Initiates |
|------|------|------------|------------|---------------|
| `deposit` | Customer deposits | Customer wallet +$ | Stripe ‚Üí Platform | Customer |
| `wallet_transfer` | Offer accepted | Customer -$, Admin +$ | None | System |
| `platform_fee` | (Deprecated) | N/A | N/A | N/A |
| `service_fee` | (Deprecated) | N/A | N/A | N/A |
| `contractor_payout` | Job completion | Admin -$, Contractor +$ | Platform ‚Üí Contractor | Admin |
| `refund` | Cancel/Reject | Admin -$, Customer +$ | None | System |
| `withdrawal` | Contractor withdraws | Contractor -$ | Platform ‚Üí Contractor | Admin |

---

## Database Models

### Wallet Model

Location: `src/db/models/wallet.model.ts`

```typescript
interface IWallet {
  user: ObjectId;                    // Reference to user
  balance: number;                   // Single balance (no escrow)
  currency: string;                  // Default: "USD"
  isActive: boolean;                 // Account status
  isFrozen: boolean;                 // Admin freeze control
  totalEarnings: number;             // Lifetime earnings
  totalSpent: number;                // Lifetime spending
  totalWithdrawals: number;          // Lifetime withdrawals
  stripeCustomerId?: string;         // For deposits (all users)
  stripeConnectAccountId?: string;   // For payouts (contractors only)
  createdAt: Date;
  updatedAt: Date;
}
```

**Key Changes**:
- ‚ùå Removed `escrowBalance` field
- ‚úÖ Single `balance` field tracks everything
- ‚úÖ Both customers and contractors can have `stripeCustomerId`
- ‚úÖ Only contractors have `stripeConnectAccountId`

**Indexes**:
```typescript
walletSchema.index({ user: 1 }, { unique: true });
```

### Offer Model

Location: `src/db/models/offer.model.ts`

```typescript
interface IOffer {
  job: ObjectId;                     // (unique) One offer per job
  customer: ObjectId;
  contractor: ObjectId;
  application: ObjectId;
  amount: number;                    // Job budget (e.g., $100)
  platformFee: number;               // 5% (e.g., $5)
  serviceFee: number;                // 20% (e.g., $20)
  contractorPayout: number;          // 80% (e.g., $80)
  totalCharge: number;               // Total (e.g., $105)
  timeline: string;
  description: string;
  status: 'pending' | 'accepted' | 'rejected' | 'cancelled' | 'completed' | 'expired';
  acceptedAt?: Date;
  rejectedAt?: Date;
  cancelledAt?: Date;
  completedAt?: Date;
  expiresAt: Date;                   // 7 days from creation
  rejectionReason?: string;
  cancellationReason?: string;
  createdAt: Date;
  updatedAt: Date;
}
```

**Indexes**:
```typescript
offerSchema.index({ job: 1 }, { unique: true });  // One offer per job
offerSchema.index({ customer: 1 });
offerSchema.index({ contractor: 1 });
offerSchema.index({ status: 1 });
```

### Transaction Model

Location: `src/db/models/transaction.model.ts`

```typescript
interface ITransaction {
  type: 'deposit' | 'withdrawal' | 'wallet_transfer' | 'contractor_payout' | 'refund';
  amount: number;
  from?: ObjectId;                   // Sender user (populated)
  to?: ObjectId;                     // Receiver user (populated)
  offer?: ObjectId;                  // Related offer
  job?: ObjectId;                    // Related job
  status: 'pending' | 'completed' | 'failed';
  description: string;
  failureReason?: string;
  stripePaymentIntentId?: string;    // For deposits
  stripeTransferId?: string;         // For payouts/withdrawals
  stripeCheckoutSessionId?: string;  // For deposits
  completedAt?: Date;
  createdAt: Date;
  updatedAt: Date;
}
```

**Indexes**:
```typescript
transactionSchema.index({ from: 1 });
transactionSchema.index({ to: 1 });
transactionSchema.index({ type: 1, status: 1 });
transactionSchema.index({ createdAt: -1 });
```

---

## Payment Configuration

Location: `src/common/payment-config.ts`

```typescript
export const PAYMENT_CONFIG = {
  // Commission rates
  PLATFORM_FEE_RATE: 0.05,           // 5%
  SERVICE_FEE_RATE: 0.20,            // 20%
  CONTRACTOR_PAYOUT_RATE: 0.80,      // 80%
  
  // Limits
  MIN_DEPOSIT: 10,                   // $10
  MAX_DEPOSIT: 100000,               // $100,000
  MIN_WITHDRAWAL: 10,                // $10
  MAX_WITHDRAWAL: 10000,             // $10,000
  MIN_OFFER: 10,                     // $10
  MAX_OFFER: 10000,                  // $10,000
  
  // Timing
  OFFER_EXPIRATION_DAYS: 7,          // 7 days
  
  // Currency
  DEFAULT_CURRENCY: 'USD',
  
  // Stripe
  STRIPE_SUCCESS_URL: process.env.FRONTEND_URL + '/payment/success',
  STRIPE_CANCEL_URL: process.env.FRONTEND_URL + '/payment/cancel',
} as const;

// Helper functions
export function calculateCommissions(amount: number) {
  const platformFee = Math.round(amount * PAYMENT_CONFIG.PLATFORM_FEE_RATE * 100) / 100;
  const serviceFee = Math.round(amount * PAYMENT_CONFIG.SERVICE_FEE_RATE * 100) / 100;
  const contractorPayout = Math.round(amount * PAYMENT_CONFIG.CONTRACTOR_PAYOUT_RATE * 100) / 100;
  const totalCharge = amount + platformFee;
  
  return {
    amount,
    platformFee,
    serviceFee,
    contractorPayout,
    totalCharge,
    adminCommission: platformFee + serviceFee
  };
}
```

---

## Service Layer Implementation

### Wallet Service

Location: `src/api/wallet/services/wallet.service.ts`

#### Get Wallet

```typescript
async function getWallet(userId: string) {
  let wallet = await WalletModel.findOne({ user: userId });
  
  if (!wallet) {
    // Auto-create wallet on first access
    wallet = await WalletModel.create({
      user: userId,
      balance: 0,
      currency: PAYMENT_CONFIG.DEFAULT_CURRENCY,
      isActive: true,
      isFrozen: false,
      totalEarnings: 0,
      totalSpent: 0,
      totalWithdrawals: 0,
    });
  }
  
  return wallet;
}
```

#### Create Deposit (Stripe Checkout)

```typescript
async function createDeposit(userId: string, amount: number) {
  // Validation
  if (amount < PAYMENT_CONFIG.MIN_DEPOSIT) {
    throw new PaymentError(`Minimum deposit is $${PAYMENT_CONFIG.MIN_DEPOSIT}`);
  }
  
  const wallet = await getWallet(userId);
  
  if (wallet.isFrozen) {
    throw new PaymentError('Wallet is frozen. Contact support.');
  }
  
  // Get or create Stripe customer
  let stripeCustomerId = wallet.stripeCustomerId;
  if (!stripeCustomerId) {
    const user = await UserModel.findById(userId);
    const customer = await stripe.customers.create({
      email: user.email,
      name: user.name,
      metadata: { userId: userId }
    });
    stripeCustomerId = customer.id;
    wallet.stripeCustomerId = stripeCustomerId;
    await wallet.save();
  }
  
  // Create Stripe Checkout Session
  const session = await stripe.checkout.sessions.create({
    customer: stripeCustomerId,
    line_items: [{
      price_data: {
        currency: 'usd',
        product_data: {
          name: 'Wallet Deposit',
          description: `Add $${amount} to your JobSphere wallet`,
        },
        unit_amount: Math.round(amount * 100), // Convert to cents
      },
      quantity: 1,
    }],
    mode: 'payment',
    success_url: PAYMENT_CONFIG.STRIPE_SUCCESS_URL,
    cancel_url: PAYMENT_CONFIG.STRIPE_CANCEL_URL,
    metadata: {
      userId: userId,
      type: 'deposit',
      amount: amount.toString(),
    },
  });
  
  // Create pending transaction (will be completed by webhook)
  await TransactionModel.create({
    type: 'deposit',
    amount,
    to: userId,
    status: 'pending',
    description: `Deposit $${amount} via Stripe`,
    stripeCheckoutSessionId: session.id,
  });
  
  return {
    checkoutUrl: session.url,  // Return URL for client to open in browser
    sessionId: session.id,
  };
}
```

#### Request Withdrawal

```typescript
async function requestWithdrawal(userId: string, amount: number) {
  const user = await UserModel.findById(userId);
  
  if (user.role !== 'contractor') {
    throw new PaymentError('Only contractors can withdraw funds');
  }
  
  const wallet = await getWallet(userId);
  
  if (wallet.isFrozen) {
    throw new PaymentError('Wallet is frozen. Contact support.');
  }
  
  if (amount < PAYMENT_CONFIG.MIN_WITHDRAWAL || amount > PAYMENT_CONFIG.MAX_WITHDRAWAL) {
    throw new PaymentError(`Withdrawal must be between $${PAYMENT_CONFIG.MIN_WITHDRAWAL} and $${PAYMENT_CONFIG.MAX_WITHDRAWAL}`);
  }
  
  if (wallet.balance < amount) {
    throw new PaymentError(`Insufficient balance. Available: $${wallet.balance}, Required: $${amount}`);
  }
  
  // Check Stripe Connect account
  if (!wallet.stripeConnectAccountId) {
    throw new PaymentError('Please complete Stripe Connect onboarding first');
  }
  
  // Create pending withdrawal request
  const withdrawal = await WithdrawalRequestModel.create({
    user: userId,
    amount,
    status: 'pending',
    requestedAt: new Date(),
  });
  
  // Note: Admin will approve and process via Stripe Connect
  
  return {
    withdrawal,
    message: 'Withdrawal request submitted. Admin will review and process.',
  };
}
```

### Offer Service

Location: `src/api/job-request/services/offer.service.ts`

#### Send Offer

```typescript
async function sendOffer(
  customerId: string,
  applicationId: string,
  data: { amount: number; timeline: string; description: string }
) {
  const session = await mongoose.startSession();
  session.startTransaction();
  
  try {
    // Get application and validate
    const application = await ApplicationModel.findById(applicationId).session(session);
    if (!application) throw new NotFoundError('Application not found');
    if (application.status !== 'pending') throw new PaymentError('Application already processed');
    
    const job = await JobModel.findById(application.job).session(session);
    if (!job) throw new NotFoundError('Job not found');
    if (job.status !== 'open') throw new PaymentError('Job is not open for offers');
    if (job.postedBy.toString() !== customerId) throw new ForbiddenError('Not authorized');
    
    // Check for existing offer
    const existingOffer = await OfferModel.findOne({ job: job._id }).session(session);
    if (existingOffer) throw new PaymentError('An offer already exists for this job');
    
    // Calculate commissions
    const commissions = calculateCommissions(data.amount);
    
    // Check customer balance
    const customerWallet = await getWallet(customerId);
    if (customerWallet.balance < commissions.totalCharge) {
      throw new PaymentError(
        `Insufficient balance. Required: $${commissions.totalCharge}, Available: $${customerWallet.balance}`
      );
    }
    
    // Create offer
    const offer = await OfferModel.create([{
      job: job._id,
      customer: customerId,
      contractor: application.contractorId,
      application: applicationId,
      amount: data.amount,
      platformFee: commissions.platformFee,
      serviceFee: commissions.serviceFee,
      contractorPayout: commissions.contractorPayout,
      totalCharge: commissions.totalCharge,
      timeline: data.timeline,
      description: data.description,
      status: 'pending',
      expiresAt: new Date(Date.now() + PAYMENT_CONFIG.OFFER_EXPIRATION_DAYS * 24 * 60 * 60 * 1000),
    }], { session });
    
    await session.commitTransaction();
    
    return offer[0];
  } catch (error) {
    await session.abortTransaction();
    throw error;
  } finally {
    session.endSession();
  }
}
```

#### Accept Offer

```typescript
async function acceptOffer(contractorId: string, offerId: string) {
  const session = await mongoose.startSession();
  session.startTransaction();
  
  try {
    const offer = await OfferModel.findById(offerId).session(session);
    if (!offer) throw new NotFoundError('Offer not found');
    if (offer.contractor.toString() !== contractorId) throw new ForbiddenError('Not authorized');
    if (offer.status !== 'pending') throw new PaymentError('Offer already processed');
    
    // Check expiration
    if (new Date() > offer.expiresAt) {
      offer.status = 'expired';
      await offer.save({ session });
      throw new PaymentError('Offer has expired');
    }
    
    // Get admin wallet
    const adminWallet = await getAdminWallet();
    const customerWallet = await getWallet(offer.customer.toString());
    
    // Wallet updates (DB only, no real money transfer)
    customerWallet.balance -= offer.totalCharge;
    customerWallet.totalSpent += offer.totalCharge;
    await customerWallet.save({ session });
    
    adminWallet.balance += offer.totalCharge;
    await adminWallet.save({ session });
    
    // Create transaction record
    await TransactionModel.create([{
      type: 'wallet_transfer',
      amount: offer.totalCharge,
      from: offer.customer,
      to: adminWallet.user,
      offer: offer._id,
      job: offer.job,
      status: 'completed',
      description: `Offer accepted - $${offer.totalCharge} transferred to admin`,
      completedAt: new Date(),
    }], { session });
    
    // Update offer
    offer.status = 'accepted';
    offer.acceptedAt = new Date();
    await offer.save({ session });
    
    // Update job
    const job = await JobModel.findById(offer.job).session(session);
    job.status = 'assigned';
    job.contractorId = offer.contractor;
    job.offerId = offer._id;
    job.assignedAt = new Date();
    await job.save({ session });
    
    // Reject other applications
    await ApplicationModel.updateMany(
      { job: job._id, _id: { $ne: offer.application } },
      { status: 'rejected' },
      { session }
    );
    
    await session.commitTransaction();
    
    return { offer, job };
  } catch (error) {
    await session.abortTransaction();
    throw error;
  } finally {
    session.endSession();
  }
}
```

#### Reject Offer

```typescript
async function rejectOffer(
  contractorId: string,
  offerId: string,
  reason?: string
) {
  const session = await mongoose.startSession();
  session.startTransaction();
  
  try {
    const offer = await OfferModel.findById(offerId).session(session);
    if (!offer) throw new NotFoundError('Offer not found');
    if (offer.contractor.toString() !== contractorId) throw new ForbiddenError('Not authorized');
    
    if (offer.status !== 'pending' && offer.status !== 'accepted') {
      throw new PaymentError('Cannot reject this offer');
    }
    
    // If offer was accepted, refund customer (wallet adjustment only)
    if (offer.status === 'accepted') {
      const adminWallet = await getAdminWallet();
      const customerWallet = await getWallet(offer.customer.toString());
      
      adminWallet.balance -= offer.totalCharge;
      await adminWallet.save({ session });
      
      customerWallet.balance += offer.totalCharge;
      await customerWallet.save({ session });
      
      // Create refund transaction
      await TransactionModel.create([{
        type: 'refund',
        amount: offer.totalCharge,
        from: adminWallet.user,
        to: offer.customer,
        offer: offer._id,
        job: offer.job,
        status: 'completed',
        description: `Offer rejected - $${offer.totalCharge} refunded to customer`,
        completedAt: new Date(),
      }], { session });
    }
    
    // Update offer
    offer.status = 'rejected';
    offer.rejectedAt = new Date();
    offer.rejectionReason = reason;
    await offer.save({ session });
    
    // Reset application status
    await ApplicationModel.findByIdAndUpdate(
      offer.application,
      { status: 'pending' },
      { session }
    );
    
    // Reset job if it was assigned
    const job = await JobModel.findById(offer.job).session(session);
    if (job.status === 'assigned') {
      job.status = 'open';
      job.contractorId = undefined;
      job.offerId = undefined;
      job.assignedAt = undefined;
      await job.save({ session });
    }
    
    await session.commitTransaction();
    
    return { offer, refundAmount: offer.status === 'accepted' ? offer.totalCharge : 0 };
  } catch (error) {
    await session.abortTransaction();
    throw error;
  } finally {
    session.endSession();
  }
}
```

### Job Completion Service

Location: `src/api/job/services/job.service.ts`

#### Complete Job (Customer Request)

```typescript
async function completeJob(customerId: string, jobId: string) {
  const job = await JobModel.findById(jobId);
  if (!job) throw new NotFoundError('Job not found');
  if (job.postedBy.toString() !== customerId) throw new ForbiddenError('Not authorized');
  if (job.status !== 'in_progress') throw new PaymentError('Job must be in progress');
  
  // Create completion request for admin
  const completionRequest = await JobCompletionRequestModel.create({
    job: jobId,
    requestedBy: customerId,
    status: 'pending',
    requestedAt: new Date(),
  });
  
  return {
    message: 'Job completion request submitted. Admin will review and approve.',
    completionRequest,
  };
}
```

#### Approve Completion (Admin)

```typescript
async function approveCompletion(adminId: string, completionRequestId: string) {
  const session = await mongoose.startSession();
  session.startTransaction();
  
  try {
    const request = await JobCompletionRequestModel.findById(completionRequestId).session(session);
    if (!request) throw new NotFoundError('Completion request not found');
    if (request.status !== 'pending') throw new PaymentError('Request already processed');
    
    const job = await JobModel.findById(request.job).session(session);
    const offer = await OfferModel.findById(job.offerId).session(session);
    
    const adminWallet = await getAdminWallet();
    const contractorWallet = await getWallet(job.contractorId.toString());
    
    // Wallet updates (DB)
    adminWallet.balance -= offer.contractorPayout;  // Admin pays contractor
    // Admin keeps: platformFee + serviceFee = $25
    await adminWallet.save({ session });
    
    contractorWallet.balance += offer.contractorPayout;
    contractorWallet.totalEarnings += offer.contractorPayout;
    await contractorWallet.save({ session });
    
    // Create transaction
    const transaction = await TransactionModel.create([{
      type: 'contractor_payout',
      amount: offer.contractorPayout,
      from: adminWallet.user,
      to: job.contractorId,
      offer: offer._id,
      job: job._id,
      status: 'pending',  // Will be completed after Stripe transfer
      description: `Job completed - $${offer.contractorPayout} payout to contractor`,
    }], { session });
    
    // Initiate Stripe Connect transfer
    const transfer = await stripe.transfers.create({
      amount: Math.round(offer.contractorPayout * 100),  // Convert to cents
      currency: 'usd',
      destination: contractorWallet.stripeConnectAccountId,
      description: `Payout for job ${job._id}`,
      metadata: {
        jobId: job._id.toString(),
        offerId: offer._id.toString(),
        transactionId: transaction[0]._id.toString(),
      },
    });
    
    // Update transaction with Stripe transfer ID
    transaction[0].stripeTransferId = transfer.id;
    transaction[0].status = 'completed';
    transaction[0].completedAt = new Date();
    await transaction[0].save({ session });
    
    // Update models
    request.status = 'approved';
    request.approvedBy = adminId;
    request.approvedAt = new Date();
    await request.save({ session });
    
    job.status = 'completed';
    job.completedAt = new Date();
    await job.save({ session });
    
    offer.status = 'completed';
    offer.completedAt = new Date();
    await offer.save({ session });
    
    await session.commitTransaction();
    
    return {
      job,
      offer,
      payout: offer.contractorPayout,
      stripeTransferId: transfer.id,
    };
  } catch (error) {
    await session.abortTransaction();
    throw error;
  } finally {
    session.endSession();
  }
}
```

---

## Stripe Integration

### Webhook Handler

Location: `src/api/webhooks/stripe.webhook.ts`

```typescript
async function handleStripeWebhook(req: Request, res: Response) {
  const sig = req.headers['stripe-signature'];
  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;
  
  let event;
  
  try {
    event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);
  } catch (err) {
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }
  
  switch (event.type) {
    case 'checkout.session.completed':
      await handleCheckoutSessionCompleted(event.data.object);
      break;
    
    case 'checkout.session.async_payment_succeeded':
      await handleCheckoutSessionCompleted(event.data.object);
      break;
    
    case 'checkout.session.async_payment_failed':
      await handleCheckoutSessionFailed(event.data.object);
      break;
    
    default:
      console.log(`Unhandled event type: ${event.type}`);
  }
  
  res.json({ received: true });
}

async function handleCheckoutSessionCompleted(session: Stripe.Checkout.Session) {
  const { userId, amount } = session.metadata;
  
  const session = await mongoose.startSession();
  session.startTransaction();
  
  try {
    // Update wallet
    const wallet = await getWallet(userId);
    wallet.balance += parseFloat(amount);
    await wallet.save({ session });
    
    // Update transaction
    await TransactionModel.findOneAndUpdate(
      { stripeCheckoutSessionId: session.id },
      {
        status: 'completed',
        completedAt: new Date(),
        stripePaymentIntentId: session.payment_intent,
      },
      { session }
    );
    
    await session.commitTransaction();
    
    // Send notification
    await notificationService.sendDepositConfirmation(userId, parseFloat(amount));
  } catch (error) {
    await session.abortTransaction();
    throw error;
  } finally {
    session.endSession();
  }
}

async function handleCheckoutSessionFailed(session: Stripe.Checkout.Session) {
  // Update transaction to failed
  await TransactionModel.findOneAndUpdate(
    { stripeCheckoutSessionId: session.id },
    {
      status: 'failed',
      failureReason: 'Payment failed',
    }
  );
  
  // Send notification
  const { userId } = session.metadata;
  await notificationService.sendDepositFailed(userId);
}
```

---

## Testing Stripe Endpoints

### Test Mode Setup

1. **Get Test API Keys**:
   - Go to Stripe Dashboard ‚Üí Developers ‚Üí API keys
   - Copy test keys (start with `sk_test_` and `pk_test_`)
   - Add to `.env`:
     ```
     STRIPE_SECRET_KEY=sk_test_...
     STRIPE_PUBLISHABLE_KEY=pk_test_...
     ```

2. **Install Stripe CLI**:
   ```bash
   # Windows (using Chocolatey)
   choco install stripe-cli
   
   # Or download from https://stripe.com/docs/stripe-cli
   ```

3. **Login to Stripe CLI**:
   ```bash
   stripe login
   ```

4. **Forward Webhooks to Local**:
   ```bash
   stripe listen --forward-to localhost:3000/api/webhooks/stripe
   ```
   - Copy the webhook signing secret (starts with `whsec_`)
   - Add to `.env`:
     ```
     STRIPE_WEBHOOK_SECRET=whsec_...
     ```

### Testing Deposit Flow

1. **Start Server**:
   ```bash
   bun dev
   ```

2. **Start Webhook Listener** (separate terminal):
   ```bash
   stripe listen --forward-to localhost:3000/api/webhooks/stripe
   ```

3. **Create Deposit Request**:
   ```bash
   curl -X POST http://localhost:3000/api/wallet/deposit \
     -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
     -H "Content-Type: application/json" \
     -d '{"amount": 50}'
   ```

4. **Expected Response**:
   ```json
   {
     "status": 200,
     "message": "Deposit initiated successfully",
     "data": {
       "checkoutUrl": "https://checkout.stripe.com/c/pay/cs_test_...",
       "sessionId": "cs_test_..."
     }
   }
   ```

5. **Open Checkout URL**:
   - Copy `checkoutUrl` and open in browser
   - Use test card: `4242 4242 4242 4242`
   - Any future expiry date
   - Any CVC
   - Complete payment

6. **Verify Webhook Received**:
   - Check Stripe CLI output for `checkout.session.completed`
   - Expected webhook log:
     ```
     --> checkout.session.completed [evt_...]
     <-- [200] POST http://localhost:3000/api/webhooks/stripe
     ```

7. **Check Wallet Balance**:
   ```bash
   curl http://localhost:3000/api/wallet \
     -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
   ```

8. **Expected Wallet Response**:
   ```json
   {
     "status": 200,
     "data": {
       "balance": 50,
       "currency": "USD",
       ...
     }
   }
   ```

### Testing Offer Flow

1. **Send Offer**:
   ```bash
   curl -X POST http://localhost:3000/api/job-request/APPLICATION_ID/send-offer \
     -H "Authorization: Bearer CUSTOMER_TOKEN" \
     -H "Content-Type: application/json" \
     -d '{
       "amount": 100,
       "timeline": "2 weeks",
       "description": "Complete the project as described"
     }'
   ```

2. **Check Wallet Deduction**:
   ```bash
   curl http://localhost:3000/api/wallet \
     -H "Authorization: Bearer CUSTOMER_TOKEN"
   ```
   - Balance should NOT change yet (only deducted on acceptance)

3. **Accept Offer**:
   ```bash
   curl -X POST http://localhost:3000/api/job-request/offer/OFFER_ID/accept \
     -H "Authorization: Bearer CONTRACTOR_TOKEN"
   ```

4. **Verify Wallet Changes**:
   - Customer wallet: -$105
   - Admin wallet: +$105
   ```bash
   curl http://localhost:3000/api/wallet \
     -H "Authorization: Bearer CUSTOMER_TOKEN"
   
   curl http://localhost:3000/api/wallet \
     -H "Authorization: Bearer ADMIN_TOKEN"
   ```

### Testing Completion Flow

1. **Mark Job Complete** (Customer):
   ```bash
   curl -X POST http://localhost:3000/api/job/JOB_ID/complete \
     -H "Authorization: Bearer CUSTOMER_TOKEN"
   ```

2. **Approve Completion** (Admin):
   ```bash
   curl -X POST http://localhost:3000/api/admin/completion-requests/REQUEST_ID/approve \
     -H "Authorization: Bearer ADMIN_TOKEN"
   ```

3. **Verify Payouts**:
   - Admin wallet: -$80 (keeps $25 commission)
   - Contractor wallet: +$80
   - Stripe transfer initiated

4. **Check Stripe Dashboard**:
   - Go to Stripe Dashboard ‚Üí Payments ‚Üí Transfers
   - Verify transfer to contractor's Connect account

### Testing Withdrawal Flow

1. **Request Withdrawal** (Contractor):
   ```bash
   curl -X POST http://localhost:3000/api/wallet/withdraw \
     -H "Authorization: Bearer CONTRACTOR_TOKEN" \
     -H "Content-Type: application/json" \
     -d '{"amount": 50}'
   ```

2. **Approve Withdrawal** (Admin):
   ```bash
   curl -X POST http://localhost:3000/api/admin/withdrawal-requests/REQUEST_ID/approve \
     -H "Authorization: Bearer ADMIN_TOKEN"
   ```

3. **Verify**:
   - Contractor wallet: -$50
   - Stripe transfer to contractor's bank account

---

## Validation Checklist

### Before Deployment

- [ ] All Stripe API keys configured (test and production)
- [ ] Webhook endpoint accessible and verified
- [ ] Webhook signing secret configured
- [ ] Database indexes created
- [ ] Admin user and wallet exist
- [ ] Test deposit flow end-to-end
- [ ] Test offer acceptance flow
- [ ] Test job completion flow
- [ ] Test withdrawal flow
- [ ] Test refund scenarios
- [ ] Test error handling (insufficient balance, expired offers, etc.)
- [ ] Verify all transactions create audit trail
- [ ] Check wallet balance accuracy
- [ ] Ensure atomic operations (no partial updates)

### Production Safety

- [ ] Switch to live Stripe keys (`sk_live_`, `pk_live_`)
- [ ] Configure production webhook endpoint
- [ ] Enable Stripe Connect for contractor payouts
- [ ] Set up monitoring and alerts
- [ ] Configure error logging and tracking
- [ ] Test with small amounts first
- [ ] Have rollback plan ready
- [ ] Monitor webhook delivery
- [ ] Check for failed transactions
- [ ] Verify commission calculations

---

## Error Handling

### Common Errors

#### Insufficient Balance

```typescript
if (wallet.balance < requiredAmount) {
  throw new PaymentError(
    `Insufficient balance. Required: $${requiredAmount}, Available: $${wallet.balance}`
  );
}
```

#### Wallet Frozen

```typescript
if (wallet.isFrozen) {
  throw new PaymentError('Wallet is frozen. Please contact support.');
}
```

#### Stripe Errors

```typescript
try {
  const session = await stripe.checkout.sessions.create({...});
} catch (error) {
  if (error.type === 'StripeCardError') {
    throw new PaymentError('Card was declined');
  } else if (error.type === 'StripeInvalidRequestError') {
    throw new PaymentError('Invalid payment request');
  } else {
    throw new PaymentError('Payment processing failed');
  }
}
```

#### Transaction Rollback

```typescript
const session = await mongoose.startSession();
session.startTransaction();

try {
  // All database operations here
  await session.commitTransaction();
} catch (error) {
  await session.abortTransaction();
  throw error;
} finally {
  session.endSession();
}
```

---

## Best Practices

### Always Use Transactions

```typescript
// ‚úÖ Good
const session = await mongoose.startSession();
session.startTransaction();
try {
  await WalletModel.updateOne({...}, {}, { session });
  await TransactionModel.create([{...}], { session });
  await session.commitTransaction();
} catch (error) {
  await session.abortTransaction();
  throw error;
} finally {
  session.endSession();
}

// ‚ùå Bad (no transaction)
await WalletModel.updateOne({...});
await TransactionModel.create({...});
```

### Validate Before Modifying

```typescript
// ‚úÖ Good
const wallet = await getWallet(userId);
if (wallet.balance < amount) {
  throw new PaymentError('Insufficient balance');
}
wallet.balance -= amount;
await wallet.save();

// ‚ùå Bad (no validation)
const wallet = await getWallet(userId);
wallet.balance -= amount;  // Could go negative!
await wallet.save();
```

### Create Audit Trail

```typescript
// ‚úÖ Good - always create transaction record
await TransactionModel.create({
  type: 'wallet_transfer',
  amount,
  from: senderId,
  to: receiverId,
  status: 'completed',
  description: 'Payment for job',
  completedAt: new Date(),
});

// ‚ùå Bad - no audit trail
wallet.balance -= amount;
await wallet.save();
```

### Handle Stripe Failures

```typescript
// ‚úÖ Good
try {
  const transfer = await stripe.transfers.create({...});
  
  transaction.stripeTransferId = transfer.id;
  transaction.status = 'completed';
  await transaction.save();
} catch (error) {
  transaction.status = 'failed';
  transaction.failureReason = error.message;
  await transaction.save();
  
  // Reverse wallet changes
  // Send notification to admin
  throw error;
}
```

### Use TypeScript Types

```typescript
// ‚úÖ Good
interface SendOfferData {
  amount: number;
  timeline: string;
  description: string;
}

async function sendOffer(
  customerId: string,
  applicationId: string,
  data: SendOfferData
): Promise<IOffer> {
  // Implementation
}

// ‚ùå Bad
async function sendOffer(customerId, applicationId, data) {
  // No type safety
}
```

### Environment-Specific Keys

```typescript
// ‚úÖ Good
const stripeKey = process.env.NODE_ENV === 'production'
  ? process.env.STRIPE_LIVE_SECRET_KEY
  : process.env.STRIPE_TEST_SECRET_KEY;

const stripe = new Stripe(stripeKey);

// ‚ùå Bad - hardcoded test keys
const stripe = new Stripe('sk_test_...');
```

---

## Support

For implementation questions or issues:

- Check `doc/payment/1.MAIN-REFERENCE.md` for business logic
- Review `doc/payment/3.FRONTEND_API_GUIDE.md` for API integration
- Contact backend team: backend@jobsphere.com
- Emergency: emergency@jobsphere.com

---

**Document Version**: 2.0.0  
**Last Updated**: January 28, 2026  
**Status**: ‚úÖ Complete and Production Ready
