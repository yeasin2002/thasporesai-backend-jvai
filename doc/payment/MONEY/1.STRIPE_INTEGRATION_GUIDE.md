# JobSphere Stripe Integration Guide

**Version**: 1.0.0  
**Last Updated**: November 24, 2025  
**Status**: Implementation Required  
**Priority**: CRITICAL

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Understanding Your Current System](#understanding-your-current-system)
3. [Why Stripe Integration is Critical](#why-stripe-integration-is-critical)
4. [Stripe Concepts You Need to Know](#stripe-concepts-you-need-to-know)
5. [Integration Architecture](#integration-architecture)
6. [Implementation Roadmap](#implementation-roadmap)
7. [Detailed Implementation Guide](#detailed-implementation-guide)
8. [Webhook Integration](#webhook-integration)
9. [Security Considerations](#security-considerations)
10. [Testing Strategy](#testing-strategy)
11. [Production Deployment](#production-deployment)
12. [Troubleshooting Guide](#troubleshooting-guide)

---

## Executive Summary

### Current State

Your JobSphere payment system has a **solid foundation** with:

- ‚úÖ Well-designed wallet system (balance + escrow)
- ‚úÖ Complete transaction tracking
- ‚úÖ Proper commission calculation (5% + 20%)
- ‚úÖ Escrow-based payment flow
- ‚úÖ Atomic database operations (race condition prevention)

### Critical Gaps

However, you have **two critical blockers** preventing production deployment:

**CRITICAL #1: Stripe Integration Incomplete**

- Deposits add money without actual payment processing
- Withdrawals don't transfer real money to contractors
- System is essentially "play money" right now

**CRITICAL #3: No Webhook Handling**

- Cannot verify if Stripe actually charged customers
- Cannot handle payment failures
- Cannot process refunds properly
- Cannot handle disputes/chargebacks

### What This Guide Provides

This document will help you:

1. **Understand** how Stripe works and why it's essential
2. **Plan** your integration architecture
3. **Implement** Payment Intents for deposits
4. **Implement** Stripe Connect for contractor payouts
5. **Build** webhook handlers for payment confirmations
6. **Test** your integration thoroughly
7. **Deploy** to production safely

---

## Understanding Your Current System

### Your Money Flow (Current)

```
Customer Deposits $200
    ‚Üì
```
Wallet balance += $200 (NO ACTUAL PAYMENT!)
    ‚Üì
Customer sends $100 offer
    ‚Üì
Wallet: $95 available, $105 escrow
    ‚Üì
Contractor accepts
    ‚Üì
Platform fee $5 ‚Üí Admin wallet
    ‚Üì
Job completed
    ‚Üì
Service fee $20 ‚Üí Admin wallet
Contractor payout $80 ‚Üí Contractor wallet
    ‚Üì
Contractor withdraws $80
    ‚Üì
Wallet balance -= $80 (NO ACTUAL TRANSFER!)
```

**The Problem**: Money moves in your database, but no real money changes hands!

### Your Database Models

**Wallet Model** (`src/db/models/wallet.model.ts`):
- `balance`: Available funds
- `escrowBalance`: Funds held for pending offers
- `totalEarnings`: Lifetime earnings
- `totalSpent`: Lifetime spending
- `totalWithdrawals`: Lifetime withdrawals
- `isFrozen`: Security flag

**Transaction Model** (`src/db/models/transaction.model.ts`):
- `type`: deposit, withdrawal, escrow_hold, platform_fee, service_fee, contractor_payout, refund
- `amount`: Transaction amount
- `from`: Sender user
- `to`: Receiver user
- `status`: pending, completed, failed
- `offer`: Related offer reference
- `job`: Related job reference

### Your Current Services

**Deposit Service** (`src/api/wallet/services/deposit.service.ts`):
```typescript
// TODO: Process payment with Stripe
// For now, just add to wallet
wallet.balance += amount;
```

**Withdraw Service** (`src/api/wallet/services/withdraw.service.ts`):
```typescript
// TODO: Integrate with Stripe Connect for actual payout
// const transfer = await stripe.transfers.create({...});
```

---

## Why Stripe Integration is Critical

### 1. Legal & Compliance

**Without Stripe**:
- You're not actually processing payments
- No PCI compliance
- No fraud protection
- No regulatory compliance (KYC/AML)

**With Stripe**:
- Stripe handles PCI compliance
- Built-in fraud detection (Radar)
- Regulatory compliance managed
- Legal payment processing

### 2. Real Money Movement

**Without Stripe**:
- Database numbers change, but no money moves
- Cannot accept credit cards
- Cannot pay contractors
- Cannot handle refunds

**With Stripe**:
- Real credit card processing
- Bank transfers to contractors
- Automatic refund processing
- Dispute handling

### 3. Trust & Credibility

**Without Stripe**:
- Customers won't trust your platform
- No payment confirmation
- No payment history
- No receipts

**With Stripe**:
- Trusted payment brand
- Email receipts
- Payment history in Stripe Dashboard
- Customer confidence

### 4. Business Operations

**Without Stripe**:
- Cannot track real revenue
- No financial reporting
- Cannot reconcile payments
- Tax reporting impossible

**With Stripe**:
- Complete financial reporting
- Automatic tax calculations
- Revenue analytics
- Reconciliation tools

---

## Stripe Concepts You Need to Know

### 1. Payment Intents

**What**: A Payment Intent represents a single payment from a customer.

**Why**: Handles complex payment flows including:
- 3D Secure authentication
- Retry logic
- Idempotency
- Status tracking

**Lifecycle**:
```
created ‚Üí requires_payment_method ‚Üí requires_confirmation 
‚Üí requires_action ‚Üí processing ‚Üí succeeded/failed
```

**Your Use Case**: Customer deposits money into wallet

### 2. Stripe Connect

**What**: Platform for marketplaces to pay sellers/contractors.

**Why**: Allows you to:
- Onboard contractors
- Verify their identity (KYC)
- Pay them directly
- Handle their taxes

**Account Types**:
- **Standard**: Contractor manages their own Stripe account
- **Express**: You manage account, contractor has limited access
- **Custom**: You fully manage account (most control)

**Your Use Case**: Contractor withdrawals and payouts

### 3. Webhooks

**What**: HTTP callbacks from Stripe when events occur.

**Why**: Asynchronous payment confirmation:
- Payment succeeded
- Payment failed
- Transfer completed
- Dispute created

**Critical Events**:
- `payment_intent.succeeded`: Deposit confirmed
- `payment_intent.payment_failed`: Deposit failed
- `transfer.paid`: Withdrawal completed
- `charge.refunded`: Refund processed

**Your Use Case**: Confirm deposits, handle failures, verify transfers

### 4. Idempotency

**What**: Preventing duplicate charges.

**Why**: Network issues can cause retries.

**How**: Send `Idempotency-Key` header with unique ID.

**Your Use Case**: Prevent double-charging customers

### 5. Metadata

**What**: Custom data attached to Stripe objects.

**Why**: Link Stripe payments to your database.

**Example**:
```javascript
metadata: {
  userId: "user123",
  walletId: "wallet456",
  transactionId: "txn789"
}
```

**Your Use Case**: Connect Stripe payments to your transactions

---

## Integration Architecture

### High-Level Overview

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Customer  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ 1. Deposit $200
       ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Your Frontend      ‚îÇ
‚îÇ  (React/Flutter)    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ 2. POST /api/wallet/deposit
       ‚îÇ    {amount: 200, paymentMethodId}
       ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Your Backend       ‚îÇ
‚îÇ  (Express/Node.js)  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ 3. Create Payment Intent
       ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Stripe API         ‚îÇ
‚îÇ  (Payment Intent)   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ 4. Process Payment
       ‚îÇ    (Async)
       ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Stripe Webhook     ‚îÇ
‚îÇ  (Confirmation)     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ 5. payment_intent.succeeded
       ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Your Webhook       ‚îÇ
‚îÇ  Handler            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ 6. Update wallet balance
       ‚îÇ    Complete transaction
       ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Your Database      ‚îÇ
‚îÇ  (MongoDB)          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Component Breakdown

**1. Frontend (Client-Side)**
- Collects payment method (card details)
- Creates Payment Method with Stripe.js
- Sends Payment Method ID to backend
- Handles 3D Secure if required

**2. Backend (Server-Side)**
- Creates Payment Intent with Stripe
- Stores pending transaction
- Returns client secret to frontend
- Waits for webhook confirmation

**3. Stripe (Payment Processing)**
- Charges customer's card
- Handles authentication
- Processes payment
- Sends webhook event

**4. Webhook Handler**
- Receives payment confirmation
- Updates wallet balance
- Completes transaction record
- Sends notification to user

---

## Implementation Roadmap

### Phase 1: Setup & Configuration (Day 1)

**Tasks**:
1. Create Stripe account
2. Get API keys (test mode)
3. Install Stripe SDK
4. Configure environment variables
5. Create Stripe service file

**Deliverables**:
- Stripe account created
- API keys secured
- Dependencies installed
- Configuration complete

### Phase 2: Deposit Implementation (Days 2-3)

**Tasks**:
1. Update wallet model (add Stripe fields)
2. Implement Payment Intent creation
3. Update deposit service
4. Handle payment confirmation
5. Test with test cards

**Deliverables**:
- Customers can deposit real money
- Payment confirmation works
- Transaction records accurate
- Error handling complete

### Phase 3: Webhook Integration (Days 4-5)

**Tasks**:
1. Create webhook endpoint
2. Implement signature verification
3. Handle payment events
4. Handle failure events
5. Test with Stripe CLI

**Deliverables**:
- Webhook endpoint live
- Payment confirmations automated
- Failure handling works
- Idempotency implemented

### Phase 4: Stripe Connect Setup (Days 6-7)

**Tasks**:
1. Enable Stripe Connect
2. Choose account type
3. Implement onboarding flow
4. Store Connect account IDs
5. Test account creation

**Deliverables**:
- Contractors can connect accounts
- KYC verification works
- Account IDs stored
- Onboarding flow complete

### Phase 5: Withdrawal Implementation (Days 8-9)

**Tasks**:
1. Update withdrawal service
2. Implement Stripe transfers
3. Handle transfer webhooks
4. Test payouts
5. Error handling

**Deliverables**:
- Contractors receive real money
- Transfer confirmation works
- Bank account validation
- Error handling complete

### Phase 6: Testing & Refinement (Days 10-12)

**Tasks**:
1. End-to-end testing
2. Error scenario testing
3. Performance testing
4. Security audit
5. Documentation

**Deliverables**:
- All flows tested
- Edge cases handled
- Performance optimized
- Documentation complete

### Phase 7: Production Deployment (Days 13-14)

**Tasks**:
1. Switch to live API keys
2. Configure production webhooks
3. Deploy to production
4. Monitor initial transactions
5. Support readiness

**Deliverables**:
- Live payment processing
- Monitoring active
- Support team trained
- Rollback plan ready

---

## Detailed Implementation Guide

### Step 1: Stripe Account Setup

**1.1 Create Stripe Account**
```
1. Go to https://stripe.com
2. Click "Sign up"
3. Enter business details
4. Verify email
5. Complete business profile
```

**1.2 Get API Keys**
```
1. Go to Dashboard ‚Üí Developers ‚Üí API keys
2. Copy "Publishable key" (starts with pk_test_)
3. Copy "Secret key" (starts with sk_test_)
4. Store securely (never commit to git)
```

**1.3 Enable Test Mode**
```
1. Toggle "Test mode" ON (top right)
2. Use test keys for development
3. Switch to live keys for production
```

### Step 2: Install Dependencies

```bash
# Install Stripe SDK
npm install stripe

# Install types (if using TypeScript)
npm install --save-dev @types/stripe
```

### Step 3: Environment Configuration

**Add to `.env`**:
```env
# Stripe Configuration
STRIPE_SECRET_KEY=sk_test_your_key_here
STRIPE_PUBLISHABLE_KEY=pk_test_your_key_here
STRIPE_WEBHOOK_SECRET=whsec_your_secret_here

# Stripe Connect (for contractor payouts)
STRIPE_CONNECT_CLIENT_ID=ca_your_client_id_here

# Currency
PAYMENT_CURRENCY=usd

# Platform Details
PLATFORM_NAME=JobSphere
PLATFORM_EMAIL=support@jobsphere.com
```

### Step 4: Create Stripe Service

**Create `src/lib/stripe.ts`**:
```typescript
import Stripe from "stripe";

if (!process.env.STRIPE_SECRET_KEY) {
  throw new Error("STRIPE_SECRET_KEY is not defined");
}

export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {
  apiVersion: "2024-11-20.acacia", // Latest version
  typescript: true,
});

// Helper to convert dollars to cents
export const dollarsToCents = (dollars: number): number => {
  return Math.round(dollars * 100);
};

// Helper to convert cents to dollars
export const centsToDollars = (cents: number): number => {
  return cents / 100;
};
```

### Step 5: Update Wallet Model

**Add Stripe fields to `src/db/models/wallet.model.ts`**:
```typescript
export interface Wallet {
  user: Types.ObjectId;
  balance: number;
  escrowBalance: number;
  currency: string;
  isActive: boolean;
  isFrozen: boolean;
  totalEarnings: number;
  totalSpent: number;
  totalWithdrawals: number;
  
  // NEW: Stripe fields
  stripeCustomerId?: string;      // For deposits
  stripeConnectAccountId?: string; // For withdrawals (contractors)
  stripeConnectOnboarded?: boolean; // KYC complete
}
```

**Update schema**:
```typescript
const walletSchema = new Schema<WalletDocument>(
  {
    // ... existing fields ...
    
    // Stripe fields
    stripeCustomerId: {
      type: String,
      index: true,
    },
    stripeConnectAccountId: {
      type: String,
      index: true,
    },
    stripeConnectOnboarded: {
      type: Boolean,
      default: false,
    },
  },
  { timestamps: true }
);
```

### Step 6: Update Transaction Model

**Add Stripe fields to `src/db/models/transaction.model.ts`**:
```typescript
export interface Transaction {
  type: string;
  amount: number;
  from: Types.ObjectId;
  to: Types.ObjectId;
  offer?: Types.ObjectId;
  job?: Types.ObjectId;
  status: "pending" | "completed" | "failed";
  description: string;
  failureReason?: string;
  completedAt?: Date;
  
  // NEW: Stripe fields
  stripePaymentIntentId?: string;  // For deposits
  stripeTransferId?: string;        // For withdrawals
  stripeRefundId?: string;          // For refunds
  stripeChargeId?: string;          // For charges
}
```

**Update schema**:
```typescript
const transactionSchema = new Schema<TransactionDocument>(
  {
    // ... existing fields ...
    
    // Stripe fields
    stripePaymentIntentId: {
      type: String,
      index: true,
    },
    stripeTransferId: {
      type: String,
      index: true,
    },
    stripeRefundId: {
      type: String,
      index: true,
    },
    stripeChargeId: {
      type: String,
      index: true,
    },
  },
  { timestamps: true }
);
```

---

## Deposit Implementation

### Overview

**Goal**: Allow customers to deposit real money using credit cards.

**Flow**:
1. Customer enters card details (frontend)
2. Frontend creates Payment Method (Stripe.js)
3. Frontend sends Payment Method ID to backend
4. Backend creates Payment Intent
5. Backend stores pending transaction
6. Stripe processes payment (async)
7. Stripe sends webhook
8. Backend updates wallet balance

### Backend Implementation

**Update `src/api/wallet/services/deposit.service.ts`**:

```typescript
import { db } from "@/db";
import { stripe, dollarsToCents } from "@/lib/stripe";
import { sendBadRequest, sendInternalError, sendSuccess } from "@/helpers";
import type { RequestHandler } from "express";
import type { Deposit } from "../wallet.validation";
import mongoose from "mongoose";

export const deposit: RequestHandler<{}, any, Deposit> = async (req, res) => {
  const session = await mongoose.startSession();
  session.startTransaction();
  
  try {
    const userId = req.user!.id;
    const { amount, paymentMethodId } = req.body;

    // Validate amount
    if (amount < 10) {
      await session.abortTransaction();
      return sendBadRequest(res, "Minimum deposit amount is $10");
    }

    // Get or create wallet
    let wallet = await db.wallet.findOne({ user: userId }).session(session);
    if (!wallet) {
      wallet = await db.wallet.create([{
        user: userId,
        balance: 0,
        escrowBalance: 0,
      }], { session });
      wallet = wallet[0];
    }

    // Create or retrieve Stripe customer
    let stripeCustomerId = wallet.stripeCustomerId;
    if (!stripeCustomerId) {
      const user = await db.user.findById(userId);
      const customer = await stripe.customers.create({
        email: user!.email,
        name: user!.full_name,
        metadata: {
          userId: userId.toString(),
          walletId: wallet._id.toString(),
        },
      });
      stripeCustomerId = customer.id;
      wallet.stripeCustomerId = stripeCustomerId;
      await wallet.save({ session });
    }

    // Create Payment Intent
    const paymentIntent = await stripe.paymentIntents.create({
      amount: dollarsToCents(amount),
      currency: process.env.PAYMENT_CURRENCY || "usd",
      customer: stripeCustomerId,
      payment_method: paymentMethodId,
      confirm: true, // Confirm immediately
      automatic_payment_methods: {
        enabled: true,
        allow_redirects: "never",
      },
      metadata: {
        userId: userId.toString(),
        walletId: wallet._id.toString(),
        type: "deposit",
      },
    });

    // Create pending transaction
    const transaction = await db.transaction.create([{
      type: "deposit",
      amount,
      from: userId,
      to: userId,
      status: "pending",
      description: `Wallet deposit of $${amount}`,
      stripePaymentIntentId: paymentIntent.id,
    }], { session });

    await session.commitTransaction();

    // Return response (wallet will be updated by webhook)
    return sendSuccess(res, 200, "Deposit initiated", {
      paymentIntent: {
        id: paymentIntent.id,
        status: paymentIntent.status,
        amount: amount,
      },
      transaction: transaction[0],
      message: "Payment processing. Balance will update upon confirmation.",
    });
  } catch (error: any) {
    await session.abortTransaction();
    console.error("Error processing deposit:", error);
    
    // Handle Stripe errors
    if (error.type === "StripeCardError") {
      return sendBadRequest(res, error.message);
    }
    
    return sendInternalError(res, "Failed to process deposit");
  } finally {
    session.endSession();
  }
};
```

**Key Points**:
1. **MongoDB Transaction**: Ensures atomicity
2. **Stripe Customer**: Created once, reused for future deposits
3. **Payment Intent**: Handles the actual charge
4. **Pending Transaction**: Created immediately, updated by webhook
5. **Metadata**: Links Stripe payment to your database
6. **Error Handling**: Specific handling for card errors


---

## Webhook Integration

### Why Webhooks Are Essential

**The Problem Without Webhooks**:
```
Customer deposits $200
    ‚Üì
Payment Intent created
    ‚Üì
Your API returns success
    ‚Üì
BUT... what if the payment fails?
    ‚Üì
Customer thinks they deposited
Wallet shows $200
But Stripe never charged them!
```

**The Solution With Webhooks**:
```
Customer deposits $200
    ‚Üì
Payment Intent created (status: pending)
    ‚Üì
Your API returns "processing"
    ‚Üì
Stripe processes payment (async)
    ‚Üì
Stripe sends webhook: payment_intent.succeeded
    ‚Üì
Your webhook handler updates wallet
    ‚Üì
Customer sees confirmed balance
```

### Webhook Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Stripe Server  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ POST /api/webhooks/stripe
         ‚îÇ Stripe-Signature: xxx
         ‚îÇ {
         ‚îÇ   "type": "payment_intent.succeeded",
         ‚îÇ   "data": {...}
         ‚îÇ }
         ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Your Webhook Endpoint  ‚îÇ
‚îÇ  (Express Route)        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ 1. Verify signature
         ‚îÇ 2. Parse event
         ‚îÇ 3. Handle event type
         ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Event Handler          ‚îÇ
‚îÇ  (Business Logic)       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ Update wallet
         ‚îÇ Complete transaction
         ‚îÇ Send notification
         ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Database               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Step 1: Create Webhook Route

**Create `src/api/webhooks/stripe.route.ts`**:
```typescript
import express, { type RequestHandler } from "express";
import { stripe } from "@/lib/stripe";
import { handlePaymentIntentSucceeded } from "./handlers/payment-intent-succeeded";
import { handlePaymentIntentFailed } from "./handlers/payment-intent-failed";
import { handleTransferPaid } from "./handlers/transfer-paid";
import { handleChargeRefunded } from "./handlers/charge-refunded";

export const stripeWebhook = express.Router();

// IMPORTANT: Use raw body for signature verification
const webhookHandler: RequestHandler = async (req, res) => {
  const sig = req.headers["stripe-signature"];

  if (!sig) {
    return res.status(400).send("Missing Stripe signature");
  }

  let event;

  try {
    // Verify webhook signature
    event = stripe.webhooks.constructEvent(
      req.body,
      sig,
      process.env.STRIPE_WEBHOOK_SECRET!
    );
  } catch (err: any) {
    console.error("Webhook signature verification failed:", err.message);
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }

  // Log event for debugging
  console.log(`Received webhook: ${event.type} [${event.id}]`);

  try {
    // Handle different event types
    switch (event.type) {
      case "payment_intent.succeeded":
        await handlePaymentIntentSucceeded(event);
        break;

      case "payment_intent.payment_failed":
        await handlePaymentIntentFailed(event);
        break;

      case "transfer.paid":
        await handleTransferPaid(event);
        break;

      case "charge.refunded":
        await handleChargeRefunded(event);
        break;

      default:
        console.log(`Unhandled event type: ${event.type}`);
    }

    // Always return 200 to acknowledge receipt
    return res.status(200).json({ received: true });
  } catch (error) {
    console.error("Error handling webhook:", error);
    // Still return 200 to prevent retries for unrecoverable errors
    return res.status(200).json({ received: true, error: "Processing failed" });
  }
};

// Use raw body parser for this route
stripeWebhook.post(
  "/stripe",
  express.raw({ type: "application/json" }),
  webhookHandler
);
```

### Step 2: Register Webhook Route

**Update `src/app.ts`**:
```typescript
import { stripeWebhook } from "./api/webhooks/stripe.route";

// IMPORTANT: Register webhook BEFORE json() middleware
app.use("/api/webhooks", stripeWebhook);

// Then register other middleware
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// ... rest of your routes
```

**Why This Order Matters**:
- Stripe webhooks need raw body for signature verification
- `express.json()` parses body, breaking verification
- Webhook route must come first

### Step 3: Create Event Handlers

**Create `src/api/webhooks/handlers/payment-intent-succeeded.ts`**:

```typescript
import type Stripe from "stripe";
import { db } from "@/db";
import { centsToDollars } from "@/lib/stripe";
import { sendNotification } from "@/common/service/notification.service";
import mongoose from "mongoose";

export const handlePaymentIntentSucceeded = async (
  event: Stripe.Event
) => {
  const paymentIntent = event.data.object as Stripe.PaymentIntent;
  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    // Get metadata
    const { userId, walletId, type } = paymentIntent.metadata;

    if (type !== "deposit") {
      console.log("Not a deposit payment intent, skipping");
      await session.abortTransaction();
      return;
    }

    // Find transaction
    const transaction = await db.transaction.findOne({
      stripePaymentIntentId: paymentIntent.id,
    }).session(session);

    if (!transaction) {
      console.error("Transaction not found for payment intent:", paymentIntent.id);
      await session.abortTransaction();
      return;
    }

    // Check if already processed (idempotency)
    if (transaction.status === "completed") {
      console.log("Transaction already processed:", transaction._id);
      await session.abortTransaction();
      return;
    }

    // Update wallet balance
    const amount = centsToDollars(paymentIntent.amount);
    const wallet = await db.wallet.findByIdAndUpdate(
      walletId,
      {
        $inc: { balance: amount },
      },
      { new: true, session }
    );

    if (!wallet) {
      throw new Error("Wallet not found");
    }

    // Update transaction
    transaction.status = "completed";
    transaction.completedAt = new Date();
    transaction.stripeChargeId = paymentIntent.latest_charge as string;
    await transaction.save({ session });

    await session.commitTransaction();

    // Send notification
    await sendNotification({
      userId,
      title: "Deposit Successful",
      body: `Your deposit of $${amount} has been confirmed`,
      type: "payment_received",
      data: {
        transactionId: transaction._id.toString(),
        amount: amount.toString(),
      },
    });

    console.log(`‚úÖ Deposit completed: $${amount} for user ${userId}`);
  } catch (error) {
    await session.abortTransaction();
    console.error("Error handling payment_intent.succeeded:", error);
    throw error;
  } finally {
    session.endSession();
  }
};
```

**Create `src/api/webhooks/handlers/payment-intent-failed.ts`**:
```typescript
import type Stripe from "stripe";
import { db } from "@/db";
import { sendNotification } from "@/common/service/notification.service";

export const handlePaymentIntentFailed = async (
  event: Stripe.Event
) => {
  const paymentIntent = event.data.object as Stripe.PaymentIntent;

  try {
    const { userId } = paymentIntent.metadata;

    // Find and update transaction
    const transaction = await db.transaction.findOneAndUpdate(
      { stripePaymentIntentId: paymentIntent.id },
      {
        status: "failed",
        failureReason: paymentIntent.last_payment_error?.message || "Payment failed",
      },
      { new: true }
    );

    if (!transaction) {
      console.error("Transaction not found for failed payment:", paymentIntent.id);
      return;
    }

    // Send notification
    await sendNotification({
      userId,
      title: "Deposit Failed",
      body: `Your deposit failed: ${transaction.failureReason}`,
      type: "payment_failed",
      data: {
        transactionId: transaction._id.toString(),
        reason: transaction.failureReason,
      },
    });

    console.log(`‚ùå Deposit failed for user ${userId}: ${transaction.failureReason}`);
  } catch (error) {
    console.error("Error handling payment_intent.failed:", error);
    throw error;
  }
};
```

### Step 4: Configure Webhook in Stripe Dashboard

**Development (Local Testing)**:
1. Install Stripe CLI: https://stripe.com/docs/stripe-cli
2. Login: `stripe login`
3. Forward events: `stripe listen --forward-to localhost:4000/api/webhooks/stripe`
4. Copy webhook secret from CLI output
5. Add to `.env`: `STRIPE_WEBHOOK_SECRET=whsec_xxx`

**Production**:
1. Go to Stripe Dashboard ‚Üí Developers ‚Üí Webhooks
2. Click "Add endpoint"
3. Enter URL: `https://yourdomain.com/api/webhooks/stripe`
4. Select events:
   - `payment_intent.succeeded`
   - `payment_intent.payment_failed`
   - `transfer.paid`
   - `charge.refunded`
5. Copy webhook secret
6. Add to production environment variables

### Step 5: Test Webhooks

**Using Stripe CLI**:
```bash
# Terminal 1: Start your server
npm run dev

# Terminal 2: Forward webhooks
stripe listen --forward-to localhost:4000/api/webhooks/stripe

# Terminal 3: Trigger test event
stripe trigger payment_intent.succeeded
```

**Expected Output**:
```
‚úÖ Received webhook: payment_intent.succeeded [evt_xxx]
‚úÖ Deposit completed: $100 for user user123
```

---

## Stripe Connect Implementation

### Overview

**Goal**: Allow contractors to receive real money withdrawals.

**Why Stripe Connect**:
- Handles contractor identity verification (KYC)
- Manages tax reporting (1099s)
- Enables direct bank transfers
- Provides contractor dashboard

### Account Types Comparison

| Feature | Standard | Express | Custom |
|---------|----------|---------|--------|
| Contractor sees Stripe branding | ‚úÖ | ‚úÖ | ‚ùå |
| Contractor manages account | ‚úÖ | Limited | ‚ùå |
| You control onboarding | ‚ùå | ‚úÖ | ‚úÖ |
| You handle support | ‚ùå | Shared | ‚úÖ |
| Implementation complexity | Low | Medium | High |

**Recommendation**: Start with **Express** accounts
- Good balance of control and simplicity
- Stripe handles most compliance
- You control onboarding flow
- Contractors get limited dashboard access

### Step 1: Enable Stripe Connect

1. Go to Stripe Dashboard ‚Üí Connect ‚Üí Settings
2. Click "Get started"
3. Choose "Express" account type
4. Configure branding (logo, colors)
5. Set redirect URLs:
   - Success: `https://yourdomain.com/connect/success`
   - Failure: `https://yourdomain.com/connect/failure`
6. Copy Connect Client ID
7. Add to `.env`: `STRIPE_CONNECT_CLIENT_ID=ca_xxx`

### Step 2: Create Onboarding Service

**Create `src/api/wallet/services/connect-onboarding.service.ts`**:

```typescript
import { db } from "@/db";
import { stripe } from "@/lib/stripe";
import { sendBadRequest, sendInternalError, sendSuccess } from "@/helpers";
import type { RequestHandler } from "express";

export const createConnectAccount: RequestHandler = async (req, res) => {
  try {
    const userId = req.user!.id;

    // Only contractors can create Connect accounts
    if (req.user!.role !== "contractor") {
      return sendBadRequest(res, "Only contractors can create Connect accounts");
    }

    // Get wallet
    let wallet = await db.wallet.findOne({ user: userId });
    if (!wallet) {
      wallet = await db.wallet.create({
        user: userId,
        balance: 0,
        escrowBalance: 0,
      });
    }

    // Check if already has Connect account
    if (wallet.stripeConnectAccountId) {
      return sendBadRequest(res, "Connect account already exists");
    }

    // Get user details
    const user = await db.user.findById(userId);
    if (!user) {
      return sendBadRequest(res, "User not found");
    }

    // Create Connect account
    const account = await stripe.accounts.create({
      type: "express",
      country: "US", // TODO: Make dynamic based on user location
      email: user.email,
      capabilities: {
        transfers: { requested: true },
      },
      business_type: "individual",
      metadata: {
        userId: userId.toString(),
        walletId: wallet._id.toString(),
      },
    });

    // Save account ID
    wallet.stripeConnectAccountId = account.id;
    await wallet.save();

    // Create account link for onboarding
    const accountLink = await stripe.accountLinks.create({
      account: account.id,
      refresh_url: `${process.env.FRONTEND_URL}/connect/refresh`,
      return_url: `${process.env.FRONTEND_URL}/connect/success`,
      type: "account_onboarding",
    });

    return sendSuccess(res, 200, "Connect account created", {
      accountId: account.id,
      onboardingUrl: accountLink.url,
    });
  } catch (error) {
    console.error("Error creating Connect account:", error);
    return sendInternalError(res, "Failed to create Connect account");
  }
};

export const getConnectAccountStatus: RequestHandler = async (req, res) => {
  try {
    const userId = req.user!.id;

    const wallet = await db.wallet.findOne({ user: userId });
    if (!wallet?.stripeConnectAccountId) {
      return sendSuccess(res, 200, "No Connect account", {
        connected: false,
        onboarded: false,
      });
    }

    // Get account details from Stripe
    const account = await stripe.accounts.retrieve(wallet.stripeConnectAccountId);

    // Check if onboarding is complete
    const onboarded = account.details_submitted && account.charges_enabled;

    // Update wallet
    if (onboarded !== wallet.stripeConnectOnboarded) {
      wallet.stripeConnectOnboarded = onboarded;
      await wallet.save();
    }

    return sendSuccess(res, 200, "Connect account status", {
      connected: true,
      onboarded,
      accountId: account.id,
      chargesEnabled: account.charges_enabled,
      payoutsEnabled: account.payouts_enabled,
    });
  } catch (error) {
    console.error("Error getting Connect account status:", error);
    return sendInternalError(res, "Failed to get account status");
  }
};
```

### Step 3: Update Withdrawal Service

**Update `src/api/wallet/services/withdraw.service.ts`**:
```typescript
import { db } from "@/db";
import { stripe, dollarsToCents } from "@/lib/stripe";
import { sendBadRequest, sendInternalError, sendSuccess } from "@/helpers";
import type { RequestHandler } from "express";
import type { Withdraw } from "../wallet.validation";
import mongoose from "mongoose";

export const withdraw: RequestHandler<{}, any, Withdraw> = async (req, res) => {
  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    const userId = req.user!.id;
    const { amount } = req.body;

    // Only contractors can withdraw
    if (req.user!.role !== "contractor") {
      await session.abortTransaction();
      return sendBadRequest(res, "Only contractors can withdraw funds");
    }

    // Validate amount
    if (amount < 10) {
      await session.abortTransaction();
      return sendBadRequest(res, "Minimum withdrawal amount is $10");
    }

    if (amount > 10000) {
      await session.abortTransaction();
      return sendBadRequest(res, "Maximum withdrawal amount is $10,000");
    }

    // Get wallet
    const wallet = await db.wallet.findOne({ user: userId }).session(session);
    if (!wallet) {
      await session.abortTransaction();
      return sendBadRequest(res, "Wallet not found");
    }

    // Check Connect account
    if (!wallet.stripeConnectAccountId) {
      await session.abortTransaction();
      return sendBadRequest(res, "Please connect your bank account first");
    }

    if (!wallet.stripeConnectOnboarded) {
      await session.abortTransaction();
      return sendBadRequest(res, "Please complete account verification");
    }

    // Check wallet status
    if (wallet.isFrozen) {
      await session.abortTransaction();
      return sendBadRequest(res, "Wallet is frozen. Contact support.");
    }

    // Check balance
    if (wallet.balance < amount) {
      await session.abortTransaction();
      return sendBadRequest(
        res,
        `Insufficient balance. Available: $${wallet.balance}`
      );
    }

    // Atomically update wallet
    wallet.balance -= amount;
    wallet.totalWithdrawals += amount;
    await wallet.save({ session });

    // Create Stripe transfer
    const transfer = await stripe.transfers.create({
      amount: dollarsToCents(amount),
      currency: "usd",
      destination: wallet.stripeConnectAccountId,
      metadata: {
        userId: userId.toString(),
        walletId: wallet._id.toString(),
        type: "withdrawal",
      },
    });

    // Create transaction record
    const transaction = await db.transaction.create([{
      type: "withdrawal",
      amount,
      from: userId,
      to: userId,
      status: "pending",
      description: `Withdrawal of $${amount}`,
      stripeTransferId: transfer.id,
    }], { session });

    await session.commitTransaction();

    return sendSuccess(res, 200, "Withdrawal initiated", {
      amount,
      newBalance: wallet.balance,
      transferId: transfer.id,
      estimatedArrival: "2-3 business days",
      transaction: transaction[0],
    });
  } catch (error: any) {
    await session.abortTransaction();
    console.error("Error processing withdrawal:", error);

    // Handle Stripe errors
    if (error.type === "StripeInvalidRequestError") {
      return sendBadRequest(res, error.message);
    }

    return sendInternalError(res, "Failed to process withdrawal");
  } finally {
    session.endSession();
  }
};
```

### Step 4: Create Transfer Webhook Handler

**Create `src/api/webhooks/handlers/transfer-paid.ts`**:
```typescript
import type Stripe from "stripe";
import { db } from "@/db";
import { centsToDollars } from "@/lib/stripe";
import { sendNotification } from "@/common/service/notification.service";

export const handleTransferPaid = async (event: Stripe.Event) => {
  const transfer = event.data.object as Stripe.Transfer;

  try {
    const { userId, type } = transfer.metadata;

    if (type !== "withdrawal") {
      console.log("Not a withdrawal transfer, skipping");
      return;
    }

    // Find and update transaction
    const transaction = await db.transaction.findOneAndUpdate(
      { stripeTransferId: transfer.id },
      {
        status: "completed",
        completedAt: new Date(),
      },
      { new: true }
    );

    if (!transaction) {
      console.error("Transaction not found for transfer:", transfer.id);
      return;
    }

    const amount = centsToDollars(transfer.amount);

    // Send notification
    await sendNotification({
      userId,
      title: "Withdrawal Completed",
      body: `Your withdrawal of $${amount} has been sent to your bank`,
      type: "withdrawal_completed",
      data: {
        transactionId: transaction._id.toString(),
        amount: amount.toString(),
      },
    });

    console.log(`‚úÖ Withdrawal completed: $${amount} for user ${userId}`);
  } catch (error) {
    console.error("Error handling transfer.paid:", error);
    throw error;
  }
};
```

### Step 5: Add Routes

**Update `src/api/wallet/wallet.route.ts`**:
```typescript
import { createConnectAccount, getConnectAccountStatus } from "./services/connect-onboarding.service";

// Connect account routes
wallet.post("/connect", requireAuth, requireRole("contractor"), createConnectAccount);
wallet.get("/connect/status", requireAuth, requireRole("contractor"), getConnectAccountStatus);
```

---

## Security Considerations

### 1. API Key Security

**DO**:
- ‚úÖ Store keys in environment variables
- ‚úÖ Use different keys for test/production
- ‚úÖ Rotate keys periodically
- ‚úÖ Use restricted API keys when possible

**DON'T**:
- ‚ùå Commit keys to git
- ‚ùå Log keys in console
- ‚ùå Send keys to frontend
- ‚ùå Share keys in Slack/email

### 2. Webhook Security

**Signature Verification**:
```typescript
// ALWAYS verify webhook signatures
const event = stripe.webhooks.constructEvent(
  req.body,
  sig,
  process.env.STRIPE_WEBHOOK_SECRET!
);
```

**Why**: Prevents fake webhooks from attackers

### 3. Idempotency

**Problem**: Network issues cause duplicate requests

**Solution**: Check if already processed
```typescript
if (transaction.status === "completed") {
  console.log("Already processed");
  return;
}
```

### 4. Amount Validation

**Always validate on backend**:
```typescript
if (amount < 10 || amount > 10000) {
  return sendBadRequest(res, "Invalid amount");
}
```

**Never trust frontend**: Users can manipulate client-side code

### 5. Metadata Security

**DO**:
- ‚úÖ Store user IDs
- ‚úÖ Store transaction IDs
- ‚úÖ Store internal references

**DON'T**:
- ‚ùå Store passwords
- ‚ùå Store credit card numbers
- ‚ùå Store SSNs
- ‚ùå Store sensitive PII

### 6. Error Handling

**DO**:
- ‚úÖ Log errors for debugging
- ‚úÖ Return generic messages to users
- ‚úÖ Monitor error rates

**DON'T**:
- ‚ùå Expose Stripe error details to users
- ‚ùå Return stack traces
- ‚ùå Leak internal system info

---

## Testing Strategy

### Test Cards

**Successful Payments**:
- `4242 4242 4242 4242` - Visa (succeeds)
- `5555 5555 5555 4444` - Mastercard (succeeds)

**Failed Payments**:
- `4000 0000 0000 0002` - Card declined
- `4000 0000 0000 9995` - Insufficient funds
- `4000 0000 0000 0069` - Expired card

**3D Secure**:
- `4000 0027 6000 3184` - Requires authentication

**Use any**:
- Expiry: Any future date
- CVC: Any 3 digits
- ZIP: Any 5 digits

### Test Scenarios

**Scenario 1: Successful Deposit**:
1. Customer deposits $100
2. Payment Intent created
3. Webhook confirms success
4. Wallet balance increases
5. Transaction marked completed
6. Notification sent

**Scenario 2: Failed Deposit**:
1. Customer deposits $100 with declined card
2. Payment Intent created
3. Webhook confirms failure
4. Wallet balance unchanged
5. Transaction marked failed
6. Error notification sent

**Scenario 3: Successful Withdrawal**:
1. Contractor withdraws $50
2. Balance deducted immediately
3. Transfer created
4. Webhook confirms transfer
5. Transaction marked completed
6. Notification sent

**Scenario 4: Webhook Retry**:
1. Webhook received
2. Processing fails
3. Stripe retries (up to 3 days)
4. Idempotency prevents duplicate processing

### Testing Checklist

- [ ] Deposit with valid card
- [ ] Deposit with declined card
- [ ] Deposit with insufficient funds
- [ ] Deposit with 3D Secure
- [ ] Withdrawal with sufficient balance
- [ ] Withdrawal with insufficient balance
- [ ] Withdrawal without Connect account
- [ ] Webhook signature verification
- [ ] Webhook idempotency
- [ ] Concurrent requests (race conditions)
- [ ] Network timeout handling
- [ ] Error notification delivery

---

## Production Deployment

### Pre-Launch Checklist

**Stripe Configuration**:
- [ ] Switch to live API keys
- [ ] Configure production webhooks
- [ ] Test with real cards (small amounts)
- [ ] Verify Connect settings
- [ ] Review payout schedule

**Code Review**:
- [ ] All TODOs removed
- [ ] Error handling complete
- [ ] Logging implemented
- [ ] Security audit passed
- [ ] Performance tested

**Infrastructure**:
- [ ] HTTPS enabled
- [ ] Environment variables secured
- [ ] Database backups configured
- [ ] Monitoring setup
- [ ] Alerting configured

**Documentation**:
- [ ] API documentation updated
- [ ] Support team trained
- [ ] Runbook created
- [ ] Rollback plan documented

### Go-Live Steps

**Day 1: Soft Launch**:
1. Deploy to production
2. Enable for internal testing
3. Process test transactions
4. Monitor logs closely
5. Verify webhooks working

**Day 2-3: Limited Beta**:
1. Enable for 10-20 users
2. Monitor all transactions
3. Collect feedback
4. Fix any issues
5. Verify financial reconciliation

**Day 4-7: Gradual Rollout**:
1. Increase user limit daily
2. Monitor error rates
3. Check webhook delivery
4. Verify payout processing
5. Review support tickets

**Day 8+: Full Launch**:
1. Enable for all users
2. Continue monitoring
3. Optimize performance
4. Gather analytics
5. Plan improvements

### Monitoring

**Key Metrics**:
- Payment success rate (target: >95%)
- Webhook delivery rate (target: >99%)
- Average processing time (target: <2s)
- Error rate (target: <1%)
- Support ticket volume

**Alerts**:
- Payment failure spike
- Webhook delivery failure
- API error rate increase
- Unusual transaction patterns
- Balance discrepancies

**Tools**:
- Stripe Dashboard (real-time monitoring)
- Application logs (error tracking)
- Database queries (reconciliation)
- Notification system (alerts)
- Analytics platform (trends)

---

## Troubleshooting Guide

### Common Issues

**Issue 1: Webhook Not Received**

**Symptoms**:
- Deposits stay pending
- Balance not updating
- No webhook logs

**Solutions**:
1. Check webhook endpoint is accessible
2. Verify HTTPS certificate valid
3. Check firewall rules
4. Review Stripe Dashboard webhook logs
5. Test with Stripe CLI

**Issue 2: Signature Verification Failed**

**Symptoms**:
- Webhook returns 400 error
- "Webhook signature verification failed"

**Solutions**:
1. Verify webhook secret correct
2. Check using raw body (not parsed JSON)
3. Ensure webhook route before json() middleware
4. Test signature locally

**Issue 3: Duplicate Processing**

**Symptoms**:
- Balance updated twice
- Duplicate transactions
- Duplicate notifications

**Solutions**:
1. Implement idempotency check
2. Use transaction status check
3. Add unique constraint on Stripe IDs
4. Log webhook event IDs

**Issue 4: Connect Account Issues**

**Symptoms**:
- Withdrawal fails
- "No such destination"
- Account not verified

**Solutions**:
1. Check Connect account exists
2. Verify onboarding completed
3. Check account capabilities enabled
4. Review account status in Dashboard

**Issue 5: Balance Mismatch**

**Symptoms**:
- Database balance ‚â† Stripe balance
- Missing transactions
- Reconciliation fails

**Solutions**:
1. Review all webhook events
2. Check for failed webhooks
3. Query Stripe API for truth
4. Run reconciliation script
5. Manual adjustment if needed

### Debug Checklist

When investigating issues:

1. **Check Logs**:
   - Application logs
   - Stripe Dashboard logs
   - Webhook delivery logs
   - Database query logs

2. **Verify Configuration**:
   - API keys correct
   - Webhook secret correct
   - Environment variables set
   - Routes registered

3. **Test Isolation**:
   - Test with Stripe CLI
   - Test with test cards
   - Test webhook manually
   - Test in staging first

4. **Data Verification**:
   - Check database records
   - Query Stripe API
   - Compare balances
   - Review transaction history

5. **Get Help**:
   - Stripe support (support@stripe.com)
   - Stripe documentation
   - Community forums
   - Internal team escalation

---

## Next Steps

### Immediate Actions (This Week)

1. **Setup Stripe Account**
   - Create account
   - Get API keys
   - Enable test mode

2. **Install Dependencies**
   - Install Stripe SDK
   - Configure environment
   - Create Stripe service

3. **Update Models**
   - Add Stripe fields to Wallet
   - Add Stripe fields to Transaction
   - Run database migration

4. **Implement Deposits**
   - Update deposit service
   - Test with test cards
   - Verify transaction creation

### Short Term (Next 2 Weeks)

1. **Implement Webhooks**
   - Create webhook route
   - Implement event handlers
   - Test with Stripe CLI
   - Deploy to staging

2. **Implement Connect**
   - Enable Stripe Connect
   - Create onboarding flow
   - Update withdrawal service
   - Test payouts

3. **Testing**
   - End-to-end testing
   - Error scenario testing
   - Performance testing
   - Security audit

### Medium Term (Next Month)

1. **Production Deployment**
   - Switch to live keys
   - Configure production webhooks
   - Soft launch
   - Gradual rollout

2. **Monitoring & Optimization**
   - Set up monitoring
   - Configure alerts
   - Optimize performance
   - Gather analytics

3. **Documentation & Training**
   - Update API docs
   - Train support team
   - Create runbooks
   - Document processes

---

## Conclusion

### What You've Learned

1. **Why Stripe is Essential**
   - Real payment processing
   - Legal compliance
   - Trust and credibility
   - Business operations

2. **How Stripe Works**
   - Payment Intents for deposits
   - Stripe Connect for payouts
   - Webhooks for confirmation
   - Metadata for linking

3. **Implementation Strategy**
   - Phased approach
   - Test thoroughly
   - Monitor closely
   - Deploy gradually

### Critical Success Factors

1. **Webhook Implementation**
   - Most critical component
   - Enables async confirmation
   - Handles failures properly
   - Prevents data inconsistency

2. **Security**
   - Signature verification
   - Idempotency checks
   - Amount validation
   - Error handling

3. **Testing**
   - Use test cards
   - Test all scenarios
   - Test webhooks
   - Test edge cases

4. **Monitoring**
   - Track key metrics
   - Set up alerts
   - Review logs
   - Reconcile regularly

### Final Thoughts

Your payment system has a **solid foundation**. With Stripe integration:
- ‚úÖ Customers can deposit real money
- ‚úÖ Contractors receive real payouts
- ‚úÖ Payments are confirmed automatically
- ‚úÖ System is production-ready

**Estimated Implementation Time**: 2 weeks

**Priority**: CRITICAL - Required for launch

**Next Step**: Start with Stripe account setup and deposit implementation

---

## Additional Resources

### Official Documentation
- Stripe Payment Intents: https://stripe.com/docs/payments/payment-intents
- Stripe Connect: https://stripe.com/docs/connect
- Stripe Webhooks: https://stripe.com/docs/webhooks
- Stripe CLI: https://stripe.com/docs/stripe-cli

### Your Project Documentation
- Payment System Audit: `doc/payment/MONEY/PAYMENT_SYSTEM_AUDIT.md`
- Payment Flow: `doc/payment/MONEY/jobsphere-payment-readme.md`
- Webhook Guide: `doc/payment/STRIPE_WEBHOOK_GUIDE.md`
- Dashboard Setup: `doc/payment/STRIPE_DASHBOARD_SETUP.md`

### Support
- Stripe Support: support@stripe.com
- Stripe Community: https://stripe.com/community
- Your Team: backend@jobsphere.com

---

**Document Version**: 1.0.0  
**Last Updated**: November 24, 2025  
**Status**: Ready for Implementation  
**Estimated Reading Time**: 45 minutes

**Good luck with your Stripe integration! üöÄ**
